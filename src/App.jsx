import React, { useState, useEffect, useRef } from 'react';
import { createClient } from '@supabase/supabase-js';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, BarChart, Bar } from 'recharts';
import { Loader, BarChart2, Clock, Users, Search, User, LogOut, PlusCircle, UploadCloud, Trash2, X, ArrowLeft, FileText, TestTube2, MessageSquare, Send, Globe, Edit, Code } from 'lucide-react';
import './App.css'; 
import { MarkdownRenderer, CodeOutputRenderer, JupyterNotebookContentViewer } from './NotebookRender';

import { DotLottieReact } from '@lottiefiles/dotlottie-react';

// --- SUPABASE SETUP ---
// NOTE: It's best practice to use environment variables for these keys.
const supabaseUrl = 'https://amepwiogiucmuqynxgrb.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFtZXB3aW9naXVjbXVxeW54Z3JiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI4MjQ2OTgsImV4cCI6MjA2ODQwMDY5OH0.-y2hIxFXch3nW8WnXRp0iPEKRUov7jAhczrbmK9o8-o';
const supabase = createClient(supabaseUrl, supabaseKey);

// --- NOTEBOOK ANALYSIS LOGIC (with fallback) ---
const localNotebookAnalysis = (notebookContent) => {
    try {
        const notebook = JSON.parse(notebookContent);
        let title = "Untitled Project";
        let description = "Locally analyzed notebook. Summary could not be generated by AI.";
        const tags = new Set();
        let accuracy = null;

        const firstMarkdownCell = notebook.cells.find(cell => cell.cell_type === 'markdown');
        if (firstMarkdownCell) {
            const sourceText = firstMarkdownCell.source.join('');
            const titleMatch = sourceText.match(/^#\s+(.*)/);
            title = titleMatch ? titleMatch[1] : 'Untitled Project';
        }

        notebook.cells.forEach(cell => {
            if (cell.cell_type === 'code') {
                const code = cell.source.join('\n');
                if (code.includes('sklearn')) tags.add('Scikit-learn');
                if (code.includes('pandas')) tags.add('Pandas');
                if (code.includes('tensorflow')) tags.add('TensorFlow');
                if (code.includes('torch')) tags.add('PyTorch');
                if (cell.outputs && Array.isArray(cell.outputs)) {
                    cell.outputs.forEach(output => {
                        if (output.name === 'stdout' || output.output_type === 'stream') {
                            const outputText = Array.isArray(output.text) ? output.text.join('\n') : '';
                            const accuracyMatch = outputText.match(/Accuracy:\s*(\d\.\d+)/i);
                            if (accuracyMatch && accuracyMatch[1]) {
                                accuracy = parseFloat(accuracyMatch[1]);
                            }
                        }
                    });
                }
            }
        });

        return {
            title,
            description,
            methodology: "Analysis performed by local parser.",
            tags: Array.from(tags),
            visualizations: ["N/A"],
            accuracy: accuracy,
        };
    } catch (e) {
        console.error("Local parsing failed:", e);
        return null;
    }
};

const cleanNotebookForApi = (notebookContent) => {
    try {
        const notebook = JSON.parse(notebookContent);
        const cleanedCells = notebook.cells.map(cell => {
            if (cell.cell_type === 'code') {
                const cleanedOutputs = (cell.outputs || []).map(output => {
                    if (output.data && output.data['image/png']) {
                        return { ...output, data: { 'text/plain': '[Image Output Hidden]' } };
                    }
                    return output;
                });
                return { ...cell, outputs: cleanedOutputs };
            }
            return cell;
        });
        return JSON.stringify({ ...notebook, cells: cleanedCells });
    } catch (e) {
        console.error("Error cleaning notebook:", e);
        return notebookContent; // Return original if cleaning fails
    }
};

const analyzeNotebookWithLLM = async (rawNotebookContent) => {
    const apiKey = ""; // Use your Gemini API key if required
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

    try {
        const cleanedNotebookContent = cleanNotebookForApi(rawNotebookContent);
        const prompt = `Analyze the following Jupyter notebook JSON and return a structured JSON summary with fields: "title", "description", "methodology", "tags" (array of strings), "visualizations" (array of strings describing charts), and "accuracy" (a number between 0 and 1, or null if not found). Notebook Content: ${cleanedNotebookContent}`;
        const schema = {
            type: "OBJECT",
            properties: {
                "title": { "type": "STRING" },
                "description": { "type": "STRING" },
                "methodology": { "type": "STRING" },
                "tags": { "type": "ARRAY", "items": { "type": "STRING" } },
                "visualizations": { "type": "ARRAY", "items": { "type": "STRING" } },
                "accuracy": { "type": "NUMBER" }
            },
            required: ["title", "description", "methodology", "tags", "visualizations"]
        };
        const payload = {
            contents: [{ parts: [{ text: prompt }] }],
            generationConfig: { responseMimeType: "application/json", responseSchema: schema },
        };

        const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        if (!response.ok) throw new Error(`API request failed with status ${response.status}`);

        const result = await response.json();
        if (!result.candidates || !result.candidates[0].content.parts[0].text) {
             throw new Error("Invalid response structure from API");
        }
        const llmResponse = JSON.parse(result.candidates[0].content.parts[0].text);
        return {
            title: llmResponse.title || "Untitled",
            description: llmResponse.description || "No description provided.",
            methodology: llmResponse.methodology || "No methodology provided.",
            tags: llmResponse.tags || [],
            visualizations: llmResponse.visualizations || [],
            accuracy: llmResponse.accuracy,
        };
    } catch (error) {
        console.warn(`AI analysis failed: ${error.message}. Falling back to local analysis.`);
        return localNotebookAnalysis(rawNotebookContent);
    }
};


// --- UI Components ---

const LoadingSpinner = () => (
    <div className="loading-spinner-overlay">
        <Loader className="animate-spin" size={48} color="var(--primary-color)" />
    </div>
);

const Badge = ({ children, className }) => <span className={`badge ${className || ''}`}>{children}</span>;

function AppHeader({ onNavigate, user }) {
    return (
        <header className="app-header">
            <div className="logo" onClick={() => onNavigate('dashboard')}>
                <BarChart2 size={28} />
                <h1>Insight Grid</h1>
            </div>
            <nav className="main-nav">
                <button onClick={() => onNavigate('timeline')}><Clock size={16} /> Timeline</button>
                <button onClick={() => onNavigate('users')}><Users size={16} /> Discover</button>
                <button onClick={() => onNavigate('search')}><Search size={16} /> Search</button>
                <button onClick={() => onNavigate('profile', user.id)}><User size={16} /> My Profile</button>
                <button onClick={() => supabase.auth.signOut()}><LogOut size={16} /> Logout</button>
            </nav>
        </header>
    );
}

const AuthComponent = ({ setError, error }) => {
    const [email, setEmail] = React.useState('');
    const [password, setPassword] = React.useState('');
    const [isLogin, setIsLogin] = React.useState(true);
    const [loading, setLoading] = React.useState(false);

    const handleAuth = async (e) => {
        e.preventDefault();
        setLoading(true);
        setError('');
        const { error } = isLogin
            ? await supabase.auth.signInWithPassword({ email, password })
            : await supabase.auth.signUp({ email, password });

        if (error) setError(error.message);
        setLoading(false);
    };

    return (
        <div className="auth-container">
            <div className="auth-form-wrapper">
                <div className="logo">
                    <BarChart2 size={40} />
                </div>
                <h2 className="auth-title">Welcome to Insight Grid</h2>
                <p className="auth-subtitle">Your space for data science showcases.</p>
                <form onSubmit={handleAuth}>
                    <input type="email" placeholder="Email" value={email} onChange={(e) => setEmail(e.target.value)} required className="auth-input" />
                    <input type="password" placeholder="Password" value={password} onChange={(e) => setPassword(e.target.value)} required className="auth-input" />
                    <button type="submit" disabled={loading} className="auth-button">{loading ? 'Loading...' : (isLogin ? 'Log In' : 'Sign Up')}</button>
                    {error && <p className="auth-error">{error}</p>}
                </form>
                <button onClick={() => setIsLogin(!isLogin)} className="auth-toggle">{isLogin ? 'Need an account? Sign Up' : 'Have an account? Log In'}</button>
            </div>
        </div>
    );
};

const ProjectCard = ({ project, onClick, onDelete }) => {
    const handleDelete = onDelete ? (e) => {
        e.stopPropagation();
        if (window.confirm('Are you sure you want to delete this project?')) {
            onDelete(project.id);
        }
    } : null;

    return (
        <div className="project-card" onClick={onClick}>
            <div className="project-card-header">
                <h3 className="project-card-title">{project.title}</h3>
                {onDelete && <button onClick={handleDelete} className="delete-button"><Trash2 size={16} /></button>}
            </div>
            <p className="project-card-description">{project.description?.substring(0, 100)}{project.description?.length > 100 ? '...' : ''}</p>
            <div className="tag-container">{(project.tags || []).map(tag => <Badge key={tag}>{tag}</Badge>)}</div>
            {project.accuracy != null && (<div className="project-card-accuracy"><strong>Accuracy:</strong> {(project.accuracy * 100).toFixed(2)}%</div>)}
        </div>
    );
};

const AddProjectModal = ({ isOpen, onClose, onAddProject }) => {
    const [title, setTitle] = React.useState('');
    const [description, setDescription] = React.useState('');
    const [methodology, setMethodology] = React.useState('');
    const [accuracy, setAccuracy] = React.useState('');
    const [tags, setTags] = React.useState('');
    const [loading, setLoading] = React.useState(false);

    const handleSubmit = async (e) => {
        e.preventDefault();
        setLoading(true);
        const projectData = {
            title, description, methodology,
            accuracy: accuracy ? parseFloat(accuracy) : null,
            tags: tags.split(',').map(tag => tag.trim()).filter(t => t),
            visualizations: []
        };
        await onAddProject(projectData);
        setLoading(false);
        onClose();
    };

    if (!isOpen) return null;

    return (
        <div className="modal-overlay">
            <div className="modal-content">
                <form onSubmit={handleSubmit}>
                    <div className="modal-header"><h3>Add New Project</h3><button type="button" onClick={onClose} className="close-button"><X size={20} /></button></div>
                    <div className="modal-body">
                        <input placeholder="Title" value={title} onChange={e => setTitle(e.target.value)} required />
                        <textarea placeholder="Description" value={description} onChange={e => setDescription(e.target.value)} required />
                        <textarea placeholder="Methodology" value={methodology} onChange={e => setMethodology(e.target.value)} />
                        <input type="number" step="0.01" min="0" max="1" placeholder="Accuracy (e.g., 0.96)" value={accuracy} onChange={e => setAccuracy(e.target.value)} />
                        <input placeholder="Tags (comma-separated)" value={tags} onChange={e => setTags(e.target.value)} />
                    </div>
                    <div className="modal-footer">
                        <button type="button" onClick={onClose} className="button-secondary">Cancel</button>
                        <button type="submit" disabled={loading} className="button-primary">{loading ? 'Adding...' : 'Add Project'}</button>
                    </div>
                </form>
            </div>
        </div>
    );
};

const Dashboard = ({ user, onSelectProject, onNavigate }) => {
    const [projects, setProjects] = React.useState([]);
    const [loading, setLoading] = React.useState(true);
    const [isAnalyzing, setIsAnalyzing] = React.useState(false);
    const [isModalOpen, setIsModalOpen] = React.useState(false);
    const fileInputRef = React.useRef(null);

    React.useEffect(() => { fetchProjects(); }, []);

    const fetchProjects = async () => {
        setLoading(true);
        const { data, error } = await supabase.from('projects').select('*').eq('user_id', user.id).order('created_at', { ascending: false });
        if (error) console.error('Error fetching projects:', error);
        else setProjects(data);
        setLoading(false);
    };

const addProject = async (projectData, rawNotebookContent = null) => {
    // Ensure rawNotebookContent is being passed correctly here
    console.log("Saving project with notebook content length:", rawNotebookContent ? rawNotebookContent.length : 0); // Add this log
    const { data, error } = await supabase.from('projects').insert([{
        ...projectData,
        user_id: user.id,
        // Make sure notebook_content is getting the raw JSON string
        notebook_content: rawNotebookContent ? JSON.parse(rawNotebookContent) : null // Supabase JSONB often expects an object, not a string
    }]).select();
    if (error) {
        alert('Error adding project: ' + error.message);
        console.error("Supabase insert error:", error); // Log the error for more detail
    } else if (data) {
        setProjects([data[0], ...projects]);
    }
};


    const deleteProject = async (projectId) => {
        const { error } = await supabase.from('projects').delete().eq('id', projectId);
        if (error) alert('Error deleting project: ' + error.message);
        else setProjects(projects.filter(p => p.id !== projectId));
    };

    const handleFileUpload = async (event) => {
    const file = event.target.files[0];
    if (!file) return;
    setIsAnalyzing(true);
    const reader = new FileReader();
    reader.onload = async (e) => {
        const rawContent = e.target.result; // This is the string content of the .ipynb
        console.log("Raw notebook content read from file:", rawContent.substring(0, 200) + "..."); // Log first 200 chars
        try {
            // Validate if it's parseable JSON before sending to LLM or saving
            JSON.parse(rawContent);
        } catch (parseError) {
            alert("The uploaded file is not a valid JSON .ipynb file.");
            console.error("File parsing error:", parseError);
            setIsAnalyzing(false);
            return;
        }

        const analyzedData = await analyzeNotebookWithLLM(rawContent);
        if (analyzedData) {
            await addProject(analyzedData, rawContent); // Pass the raw string content
        } else {
            alert("Failed to analyze notebook. Please check the file format or try again.");
        }
        setIsAnalyzing(false);
    };
    reader.readAsText(file);
    event.target.value = null;
};
    return (
        <>
            <AppHeader onNavigate={onNavigate} user={user} />
            <div className="page-container">
                <div className="dashboard-header">
                    <div className="welcome-message">
                        <h2>Welcome back, {user.email.split('@')[0]}!</h2>
                        <p>Here's an overview of your projects.</p>
                    </div>
                    <div className="dashboard-stats">
                        <div className="stat-card">
                            <h3>{projects.length}</h3>
                            <p>Total Projects</p>
                        </div>
                        <div className="stat-card">
                            <h3>{projects.length > 0 ? `${(projects.reduce((acc, p) => acc + (p.accuracy || 0), 0) / projects.filter(p => p.accuracy).length * 100).toFixed(1)}%` : 'N/A'}</h3>
                            <p>Avg. Accuracy</p>
                        </div>
                    </div>
                </div>
                <div className="dashboard-actions">
                    <button onClick={() => setIsModalOpen(true)} className="action-button"><PlusCircle size={16} /> Add Manually</button>
                    <input type="file" ref={fileInputRef} onChange={handleFileUpload} style={{ display: 'none' }} accept=".ipynb" />
                    <button onClick={() => fileInputRef.current.click()} className="action-button" disabled={isAnalyzing}>
                        {isAnalyzing ? <><Loader size={16} className="animate-spin" /> Analyzing...</> : <><UploadCloud size={16} /> Analyze Notebook</>}
                    </button>
                </div>
                <main className="projects-grid">
                    {loading ? <p>Loading projects...</p> : projects.length > 0 ? projects.map(project => (
                        <ProjectCard key={project.id} project={project} onClick={() => onSelectProject(project.id)} onDelete={deleteProject} />
                    )) : <p>No projects yet. Add one manually or analyze a notebook!</p>}
                </main>
                <AddProjectModal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} onAddProject={addProject} />
            </div>
        </>
    );
};

const ProjectDetailPage = ({ projectId, onNavigate, user }) => {
    const [project, setProject] = React.useState(null);
    const [author, setAuthor] = React.useState(null);
    const [comments, setComments] = React.useState([]);
    const [newComment, setNewComment] = React.useState("");
    const [loading, setLoading] = React.useState(true);
    const [activeTab, setActiveTab] = React.useState('description');
    const [notebookJson, setNotebookJson] = React.useState(null); // New state for notebook JSON
const fetchProjectData = async () => {
    setLoading(true);
    const { data: projectData, error: projectError } = await supabase
        .from('projects')
        .select('*') // Ensure '*' selects all columns, including notebook_content
        .eq('id', projectId)
        .single();

    if (projectError) {
        console.error("Error fetching project:", projectError);
        setLoading(false);
        return;
    }
    setProject(projectData);

    // Debugging logs for notebook_content
    console.log("Project data fetched:", projectData);
    console.log("Raw notebook_content from DB:", projectData.notebook_content);

    // If notebook_content is a JSONB column, it will already be a JS object
    // So, we just need to check if it's not null/undefined
    if (projectData.notebook_content) {
        // Assume it's already a JS object from Supabase JSONB
        setNotebookJson(projectData.notebook_content);
        console.log("Notebook JSON set directly:", projectData.notebook_content);
    } else {
        console.log("No notebook_content found for this project.");
        setNotebookJson(null); // Explicitly set to null if not present
    }

    // --- Fetch Author ---
    if (projectData && projectData.user_id) {
        const { data: authorData, error: authorError } = await supabase
            .from('profiles')
            .select('*, username, id')
            .eq('id', projectData.user_id)
            .single();
        if (authorError) console.error("Error fetching author:", authorError);
        else setAuthor(authorData);
    }

    // --- Fetch Comments ---
    const { data: commentsData, error: commentsError } = await supabase
        .from('comments')
        .select('*, profiles(username, id)')
        .eq('project_id', projectId)
        .order('created_at', { ascending: false });

    if (commentsError) {
        console.error("Error fetching comments:", commentsError);
        // Add more detailed logging for debugging Supabase errors
        console.error("Supabase comments error details:", commentsError);
    } else {
        setComments(commentsData);
    }

    setLoading(false);
};

    React.useEffect(() => {
        fetchProjectData();
    }, [projectId]);

    const handlePostComment = async (e) => {
        e.preventDefault();
        if (!newComment.trim()) return;

        const { data, error } = await supabase
            .from('comments')
            .insert([{ content: newComment, project_id: projectId, user_id: user.id }])
            .select('*, profiles(username, id)');

        if (error) {
            alert("Error posting comment: " + error.message);
        } else {
            setComments([data[0], ...comments]);
            setNewComment("");
        }
    };

    if (loading) return <LoadingSpinner />;
    if (!project) return <div className="page-container"><p>Project not found.</p></div>;

    const mockChartData = [
        { name: 'Feature A', value: Math.random() * 100 },
        { name: 'Feature B', value: Math.random() * 100 },
        { name: 'Feature C', value: Math.random() * 100 },
        { name: 'Feature D', value: Math.random() * 100 },
    ];

    return (
        <>
            <AppHeader onNavigate={onNavigate} user={user} />
            <div className="page-container project-detail-page">
                <button onClick={() => onNavigate('dashboard')} className="back-button"><ArrowLeft size={16} /> Back to Dashboard</button>

                <header className="project-detail-header">
                    <h1>{project.title}</h1>
                    {author && (
                        <div className="author-info" onClick={() => onNavigate('profile', author.id)}>
                            <User size={20} />
                            <span>{author.username || 'Anonymous User'}</span>
                        </div>
                    )}
                </header>

                {project.accuracy && (
                    <Badge className="accuracy-badge">Accuracy: {(project.accuracy * 100).toFixed(2)}%</Badge>
                )}

                <div className="tag-container">
                    {(project.tags || []).map(tag => <Badge key={tag}>{tag}</Badge>)}
                </div>

                <div className="tabs">
                    <button className={`tab ${activeTab === 'description' ? 'active' : ''}`} onClick={() => setActiveTab('description')}>Description</button>
                    <button className={`tab ${activeTab === 'methodology' ? 'active' : ''}`} onClick={() => setActiveTab('methodology')}>Methodology</button>
                    <button className={`tab ${activeTab === 'visualizations' ? 'active' : ''}`} onClick={() => setActiveTab('visualizations')}>Visualizations</button>
                    {notebookJson && ( // Only show notebook tab if content exists
                        <button className={`tab ${activeTab === 'notebook' ? 'active' : ''}`} onClick={() => setActiveTab('notebook')}>Notebook Content</button>
                    )}
                    <button className={`tab ${activeTab === 'comments' ? 'active' : ''}`} onClick={() => setActiveTab('comments')}>Comments</button>
                </div>

                <div className="tab-content">
                    {activeTab === 'description' && (
                        <section className="project-section">
                            <h2><FileText size={20} /> Description</h2>
                            <p>{project.description}</p>
                        </section>
                    )}
                    {activeTab === 'methodology' && (
                        <section className="project-section">
                            <h2><TestTube2 size={20} /> Methodology</h2>
                            <p>{project.methodology}</p>
                        </section>
                    )}
                    {activeTab === 'visualizations' && (
                         <section className="project-section">
                            <h2><BarChart2 size={20} /> Visualizations</h2>
                            {project.visualizations && project.visualizations.length > 0 && project.visualizations[0] !== 'N/A' ? (
                                <>
                                    <ul className="viz-list">
                                        {project.visualizations.map((viz, index) => <li key={index}>{viz}</li>)}
                                    </ul>
                                    <div style={{ width: '100%', height: 300, marginTop: '20px' }}>
                                        <ResponsiveContainer>
                                            <BarChart data={mockChartData}>
                                                <CartesianGrid strokeDasharray="3 3" stroke="var(--border-color)"/>
                                                <XAxis dataKey="name" stroke="var(--text-secondary)"/>
                                                <YAxis stroke="var(--text-secondary)"/>
                                                <Tooltip contentStyle={{ backgroundColor: 'var(--bg-color-dark)', border: '1px solid var(--border-color)' }}/>
                                                <Legend wrapperStyle={{color: 'var(--text-main)'}}/>
                                                <Bar dataKey="value" fill="var(--primary-color)" />
                                            </BarChart>
                                        </ResponsiveContainer>
                                    </div>
                                </>
                            ) : (
                                <p>No visualizations were described for this project.</p>
                            )}
                        </section>
                    )}
                    {activeTab === 'notebook' && notebookJson && (
                        <section className="project-section notebook-section">
                            <h2><Code size={20} /> Notebook Content</h2>
                            <JupyterNotebookContentViewer notebookJson={notebookJson} />
                        </section>
                    )}
                    {activeTab === 'comments' && (
                        <section className="project-section">
                            <h2><MessageSquare size={20} /> Comments</h2>
                            <form onSubmit={handlePostComment} className="comment-form">
                                <textarea
                                    placeholder="Add a comment..."
                                    value={newComment}
                                    onChange={(e) => setNewComment(e.target.value)}
                                />
                                <button type="submit"><Send size={16}/></button>
                            </form>
                            <div className="comments-list">
                                {comments.map(comment => (
                                    <div key={comment.id} className="comment-item">
                                        <div className="comment-author">{comment.profiles.username || 'A user'}</div>
                                        <div className="comment-content">{comment.content}</div>
                                        <div className="comment-date">{new Date(comment.created_at).toLocaleString()}</div>
                                    </div>
                                ))}
                            </div>
                        </section>
                    )}
                </div>
            </div>
        </>
    );
};

const UserListPage = ({ onNavigate, user }) => {
    const [users, setUsers] = React.useState([]);
    const [loading, setLoading] = React.useState(true);

    React.useEffect(() => {
        const fetchUsers = async () => {
            setLoading(true);
            const { data, error } = await supabase.from('profiles').select('*');
            if (error) console.error("Error fetching users:", error);
            else setUsers(data);
            setLoading(false);
        };
        fetchUsers();
    }, []);

    if (loading) return <LoadingSpinner />;

    return (
        <>
            <AppHeader onNavigate={onNavigate} user={user} />
            <div className="page-container">
                <h1>Discover Users</h1>
                <div className="user-list">
                    {users.map(profile => (
                        <div key={profile.id} className="user-card" onClick={() => onNavigate('profile', profile.id)}>
                            <User size={40} />
                            <div className="user-card-info">
                                <h4>{profile.username || `User ${profile.id.substring(0, 8)}`}</h4>
                                <p>{profile.website || 'No website provided'}</p>
                            </div>
                        </div>
                    ))}
                </div>
            </div>
        </>
    );
};

const UserProfilePage = ({ userId, onNavigate, currentUser }) => {
    const [profile, setProfile] = React.useState(null);
    const [projects, setProjects] = React.useState([]);
    const [loading, setLoading] = React.useState(true);

    React.useEffect(() => {
        const fetchData = async () => {
            setLoading(true);
            // Fetch profile
            const { data: profileData, error: profileError } = await supabase
                .from('profiles').select('*').eq('id', userId).single();
            if (profileError) console.error("Error fetching profile:", profileError);
            else setProfile(profileData);

            // Fetch projects
            const { data: projectsData, error: projectsError } = await supabase
                .from('projects').select('*').eq('user_id', userId).order('created_at', { ascending: false });
            if (projectsError) console.error("Error fetching projects:", projectsError);
            else setProjects(projectsData);
            
            setLoading(false);
        };
        fetchData();
    }, [userId]);

    if (loading) return <LoadingSpinner />;
    if (!profile) return (
        <>
            <AppHeader onNavigate={onNavigate} user={currentUser} />
            <div className="page-container"><p>User profile not found.</p></div>
        </>
    );

    return (
        <>
            <AppHeader onNavigate={onNavigate} user={currentUser} />
            <div className="page-container">
                <header className="profile-header">
                    <div className="profile-info">
                        <User size={64} className="profile-avatar" />
                        <div>
                            <h2>{profile.username || 'Anonymous User'}</h2>
                            <p className="profile-bio">{profile.bio || 'No bio available.'}</p>
                            <div className="profile-links">
                                {profile.website && <a href={profile.website} target="_blank" rel="noopener noreferrer"><Globe size={16} /> {profile.website}</a>}
                            </div>
                        </div>
                    </div>
                    {currentUser.id === userId && (
                        <button onClick={() => onNavigate('editProfile')} className="action-button">
                            <Edit size={16} /> Edit Profile
                        </button>
                    )}
                </header>

                <main>
                    <h3>Projects</h3>
                    <div className="projects-grid">
                        {projects.length > 0 ? projects.map(project => (
                            <ProjectCard key={project.id} project={project} onClick={() => onNavigate('project', project.id)} />
                        )) : <p>This user hasn't added any projects yet.</p>}
                    </div>
                </main>
            </div>
        </>
    );
};

const TimelinePage = ({ user, onNavigate }) => {
    const [feed, setFeed] = React.useState([]);
    const [loading, setLoading] = React.useState(true);

    React.useEffect(() => {
        const fetchFeed = async () => {
            setLoading(true);
            const { data, error } = await supabase
                .from('projects')
                .select('*, profiles(username, id)')
                .order('created_at', { ascending: false })
                .limit(50);
            
            if (error) console.error("Error fetching timeline:", error);
            else setFeed(data);
            setLoading(false);
        };
        fetchFeed();
    }, []);

    if (loading) return <LoadingSpinner />;

    return (
        <>
            <AppHeader onNavigate={onNavigate} user={user} />
            <div className="page-container">
                <h1>Timeline</h1>
                <div className="timeline-feed">
                    {feed.map(item => (
                        <div key={item.id} className="timeline-item">
                            <div className="timeline-content">
                                <h3 onClick={() => onNavigate('project', item.id)}>{item.title}</h3>
                                <p>{item.description.substring(0, 150)}...</p>
                                <div className="timeline-meta">
                                    <span onClick={() => onNavigate('profile', item.profiles.id)}>
                                        <User size={14} /> {item.profiles.username || 'A user'}
                                    </span>
                                    <span>
                                        <Clock size={14} /> {new Date(item.created_at).toLocaleDateString()}
                                    </span>
                                </div>
                            </div>
                        </div>
                    ))}
                </div>
            </div>
        </>
    );
};

const SearchPage = ({ onNavigate, user }) => {
    const [query, setQuery] = React.useState('');
    const [results, setResults] = React.useState([]);
    const [searchType, setSearchType] = React.useState('projects');
    const [isSearching, setIsSearching] = React.useState(false);

    const handleSearch = async (e) => {
        e.preventDefault();
        if (!query.trim()) return;
        
        setIsSearching(true);
        setResults([]);
        
        let data, error;
        if (searchType === 'projects') {
            ({ data, error } = await supabase
                .from('projects')
                .select('*')
                .textSearch('title', `'${query}'`)); // Basic text search
        } else { // 'users'
            ({ data, error } = await supabase
                .from('profiles')
                .select('*')
                .ilike('username', `%${query}%`));
        }

        if (error) console.error("Search error:", error);
        else setResults(data);
        setIsSearching(false);
    };

    return (
        <>
            <AppHeader onNavigate={onNavigate} user={user} />
            <div className="page-container">
                <h1>Search</h1>
                <form onSubmit={handleSearch} className="search-form">
                    <div className="search-bar">
                        <input 
                            type="search" 
                            placeholder={`Search for ${searchType}...`}
                            value={query}
                            onChange={e => setQuery(e.target.value)}
                        />
                        <button type="submit" disabled={isSearching}>{isSearching ? <Loader size={16} className="animate-spin" /> : <Search size={16} />}</button>
                    </div>
                    <div className="search-toggles">
                        <button type="button" className={searchType === 'projects' ? 'active' : ''} onClick={() => setSearchType('projects')}>Projects</button>
                        <button type="button" className={searchType === 'users' ? 'active' : ''} onClick={() => setSearchType('users')}>Users</button>
                    </div>
                </form>

                <div className="search-results">
                    {isSearching && <p>Searching...</p>}
                    {!isSearching && results.length === 0 && <p>No results found.</p>}
                    {searchType === 'projects' && (
                        <div className="projects-grid">
                            {results.map(project => <ProjectCard key={project.id} project={project} onClick={() => onNavigate('project', project.id)} />)}
                        </div>
                    )}
                    {searchType === 'users' && (
                        <div className="user-list">
                            {results.map(profile => (
                                <div key={profile.id} className="user-card" onClick={() => onNavigate('profile', profile.id)}>
                                    <User size={40} />
                                    <div className="user-card-info">
                                        <h4>{profile.username || `User ${profile.id.substring(0,8)}`}</h4>
                                        <p>{profile.website || 'No website'}</p>
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            </div>
        </>
    );
};

const EditProfilePage = ({ onNavigate, user }) => {
    const [profile, setProfile] = React.useState({ username: '', website: '', bio: '' });
    const [loading, setLoading] = React.useState(true);
    const [saving, setSaving] = React.useState(false);

    React.useEffect(() => {
        const fetchProfile = async () => {
            setLoading(true);
            const { data, error } = await supabase.from('profiles').select('*').eq('id', user.id).single();
            if (data) setProfile(data);
            // If there's an error (like profile not found), it's fine, the form will be blank
            setLoading(false);
        };
        fetchProfile();
    }, [user.id]);

    const handleUpdate = async (e) => {
        e.preventDefault();
        setSaving(true);
        const { username, website, bio } = profile;
        const { error } = await supabase.from('profiles').upsert({
            id: user.id,
            username,
            website,
            bio,
            updated_at: new Date(),
        });

        if (error) alert("Error updating profile: " + error.message);
        else {
            alert("Profile updated!");
            onNavigate('profile', user.id);
        }
        setSaving(false);
    };

    const handleChange = (e) => {
        const { name, value } = e.target;
        setProfile(prev => ({ ...prev, [name]: value }));
    };
    
    if (loading) return <LoadingSpinner />;

    return (
        <>
            <AppHeader onNavigate={onNavigate} user={user} />
            <div className="page-container">
                <button onClick={() => onNavigate('profile', user.id)} className="back-button"><ArrowLeft size={16} /> Back to Profile</button>
                <h1>Edit Profile</h1>
                <form onSubmit={handleUpdate} className="edit-profile-form">
                    <label htmlFor="username">Username</label>
                    <input id="username" name="username" value={profile.username || ''} onChange={handleChange} />
                    
                    <label htmlFor="website">Website</label>
                    <input id="website" name="website" type="url" value={profile.website || ''} onChange={handleChange} />

                    <label htmlFor="bio">Bio</label>
                    <textarea id="bio" name="bio" value={profile.bio || ''} onChange={handleChange} rows="4" />

                    <button type="submit" disabled={saving} className="button-primary">
                        {saving ? 'Saving...' : 'Save Changes'}
                    </button>
                </form>
            </div>
        </>
    );
};


// --- Main App Component with Routing ---

export default function App() {
    const [session, setSession] = React.useState(null);
    const [authError, setAuthError] = React.useState('');
    const [view, setView] = React.useState({ name: 'dashboard', id: null }); // { name, id }
    const [isAuthLoading, setIsAuthLoading] = React.useState(true);
    
    React.useEffect(() => {
        document.body.classList.add('dark-mode');
        const fetchSession = async () => {
            const { data: { session } } = await supabase.auth.getSession();
            setSession(session);
            setIsAuthLoading(false);
        };

        fetchSession();

        const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
            setSession(session);
        });

        return () => subscription.unsubscribe();
    }, []);

    const handleNavigate = (page, id = null) => {
        setView({ name: page, id });
    };

    let content;

    if (isAuthLoading) {
        content = <LoadingSpinner />;
    } else if (!session) {
        content = <AuthComponent setError={setAuthError} error={authError} />;
    } else {
        switch (view.name) {
            case 'project':
                content = <ProjectDetailPage projectId={view.id} onNavigate={handleNavigate} user={session.user} />;
                break;
            case 'profile':
                content = <UserProfilePage userId={view.id} onNavigate={handleNavigate} currentUser={session.user} />;
                break;
            case 'editProfile':
                content = <EditProfilePage onNavigate={handleNavigate} user={session.user} />;
                break;
            case 'users':
                content = <UserListPage onNavigate={handleNavigate} user={session.user} />;
                break;
            case 'timeline':
                content = <TimelinePage user={session.user} onNavigate={handleNavigate} />;
                break;
            case 'search':
                content = <SearchPage onNavigate={handleNavigate} user={session.user} />;
                break;
            default:
                content = <Dashboard user={session.user} onSelectProject={(id) => handleNavigate('project', id)} onNavigate={handleNavigate} />;
                break;
        }
    }

    return (
        <>
           
           
            {content}
        </>
    );
}
